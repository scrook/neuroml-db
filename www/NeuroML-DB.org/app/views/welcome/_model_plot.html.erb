<%
  if @meta_protocol_type == nil
    @meta_protocol_type = "Meta Protocol"
  end

  if @clamp_type == nil
    @clamp_type = "Current"
  end

  waveforms = Model.GetModelWaveFormList(@model_id)
  steady_states = Model.GetModelPlotWaveForms(@model_id, "STEADY_STATE", "null")

%>
<div id="model-plots">

  <% if waveforms != nil and waveforms.rows.length > 0 %>
      <style>
        sup { vertical-align: super; font-size: 12px; }
        .protocolButton { text-decoration:none; padding: 1px; border: 1px solid transparent; font-size: 14px; height: 40px; text-align: center; vertical-align: middle; cursor:pointer; }
        .protocolButton:first-child { margin-left: -2px; }
        .conditions .selected { border-color:#1376c4; }
        .protocols, .meta-protocols { margin-bottom: 10px; }
        .meta-protocol { display:none; }
        canvas { -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none; }
        table { border: 0px; }
        #plot-selectors { margin-bottom: 15px; }
        .selector { width: 261px; float:left; margin-left: 30px; font-size: 16px; }
        .selector select { margin: 0; border: 1px solid #c5c5c5; font-size: 16px; width: 100%; margin-top: -11px; }
        .selector .caption { text-align: center; height: 28px; }
        .selector .slider {  }
        .selector .value { font-weight: bold; }
      </style>
      <script>
          var waveforms = <%= waveforms.to_json.html_safe  %>;
          var steady_state_waveforms = <%= steady_states.to_json.html_safe %>;
          var model_type = '<%= @type %>';
          var model_id = '<%= @model_id %>';
          var waveform_selection = { 'protocol': null, 'meta_protocol': null, 'label': null };
          var waveform_cached_urls = {};
          var waveform_cache = [];

          variables = Enumerable
                  .from(waveforms)
                  .select(function(w) { return { "Name": w["Variable_Name"], "Units": w["Units"] } })
                  .distinct(v => v["Name"])
                  .toArray();

          function plotsInit() {

              //Prepare steady states
              steady_state_waveforms = Enumerable
                      .from(steady_state_waveforms)
                      .select(w => to_chartjs_format(w))
                      .toArray();

              //Create canvases for each variable
              Enumerable.from(variables).forEach(v => {
                  canvasID = "canvas"+v["Name"];
                  title = v["Name"] + " (" + v["Units"] + ")";
                  jQuery('<canvas id="'+canvasID+'" width="874" height="219"></canvas>').appendTo("#canvases");
                  setupChart(canvasID, title, { "datasets": []});
              });

              // Create protocol dropdown
              Enumerable
                  .from(waveforms)
                  .select(function(w) { return { "ID": w["Protocol_ID"], "Name":w["Protocol"]} })
                  .distinct(function(p) { return p["ID"]+p["Name"] })
                  .forEach(function(p) {
                      jQuery('<option value="'+p['ID']+'">'+p['Name']+'</option>')
                          .appendTo('#protocols select');
                  });

              //Create meta-protocols slider
              jQuery("#meta-protocols .slider")
                  .slider({
                      slide: function( event, ui ) {
                          onMetaProtocolSelected(ui.value);
                      },
                      change: function( event, ui ) {
                          onMetaProtocolSelected(ui.value);
                      }
                  });

              //Create meta-protocols slider
              jQuery("#labels .slider")
                  .slider({
                      slide: function( event, ui ) {
                          onLabelSelected(ui.value);
                      },
                      change: function( event, ui ) {
                          onLabelSelected(ui.value);
                      }
                  });

              //Wire up the dropdown and trigger it
              jQuery("#protocols select").on("change", onProtocolSelected)
              jQuery("#protocols select").change()
          }

          function to_chartjs_format(wave) {
              starts_from_SS = Enumerable
                      .from(waveforms)
                      .first(w => w["ID"] == wave["ID"])
                      ["Starts_From_Steady_State"] == 1;

              var chart_data = [];

              //Prefix steady state data to the waveform
              if(starts_from_SS) {
                  chart_data = chart_data.concat(Enumerable
                          .from(steady_state_waveforms)
                          .first(w => w["Variable_Name"] == wave["Variable_Name"])
                          ["data"])
              }

              var values = wave["Variable_Values"].split(',').map(v => parseFloat(v));

              var chart_x = wave["Time_Start"];
              var chart_x_step = wave["Time_Step"];

              for (v = 0; v < values.length; v++) {
                  var chart_dp = {"x": chart_x, "y": values[v]};
                  chart_data.push(chart_dp);
                  chart_x += chart_x_step;
              }

              var max_y = Enumerable.from(chart_data).max(dp => dp["y"]);
              var min_y = Enumerable.from(chart_data).min(dp => dp["y"]);

              var max_x = Enumerable.from(chart_data).max(dp => dp["x"]);
              var min_x = Enumerable.from(chart_data).min(dp => dp["x"]);

              //Simplify the waveform with Ramer Douglas Peucker algo. From: http://karthaus.nl/rdp/
              //Waveform changes less than % of the Y range are linearized
              var simplification_epsilon = (max_y - min_y) * 0.01;

              chart_data = Enumerable
                  .from(RDPsd(Enumerable
                          .from(chart_data)
                          .select(dp => [dp["x"], dp["y"]])
                          .toArray(), simplification_epsilon))
                  .select(function(dp) { return {"x": dp[0], "y": dp[1] } } )
                  .toArray();


              wave["Variable_Values"] = null; //Remove old format
              wave["data"] = chart_data;
              wave["min_y"] = min_y;
              wave["max_y"] = max_y;
              wave["min_x"] = min_x;
              wave["max_x"] = max_x;

              wave["label"] = wave["Waveform_Label"];
              wave["backgroundColor"] = 'rgba(0,0,250,1)';
              wave["borderColor"] = 'rgba(0,0,250,1)';

              return wave
          }
          function onProtocolSelected() {
              var protocol_id = this.value;

              waveform_selection = { 'protocol': protocol_id, 'meta_protocol': null, 'label': null };

              // Create meta protocol buttons
              var metas = Enumerable
                  .from(waveforms)
                  .where(function(w) { return w["Protocol_ID"] == protocol_id })
                  .select(function(w) { return { "ID": w["Meta_Protocol_ID"], "Name": w["Meta_Protocol"]} })
                  .distinct(function(p) { return p["ID"]+p["Name"] });

              var metas_slider_div = jQuery("#meta-protocols .slider");

              //Update their array
              meta_protocols_lookup = metas.toArray()

              if (meta_protocols_lookup.length > 1) {
                  metas_slider_div.slider('option','max', meta_protocols_lookup.length - 1);

                  //For channels, keep same meta-protocol, across protocols (all same)
                  if (model_type == "Channel") {
                      var current_value = metas_slider_div.slider('value');

                      //Trigger slider change event, to update protocol stimuli
                      metas_slider_div.slider('value', current_value)
                  }
                  //For other models, select the first meta-protocol
                  else {
                      metas_slider_div.slider('value', 0)
                  }

                  jQuery("#meta-protocols").show();
              }
              else {
                  onMetaProtocolSelected(0);

                  jQuery("#meta-protocols").hide();
              }
          }

          function onMetaProtocolSelected(slider_value) {
              meta_protocol = meta_protocols_lookup[slider_value]

              //Update the value
              jQuery( "#meta-protocols .value" ).html(meta_protocol["Name"]);
              waveform_selection["meta_protocol"] = meta_protocol["ID"];

              updateLabels();
          }

          function updateLabels() {

              // Create protocol buttons
              var labels = Enumerable
                  .from(waveforms)
                  .where(function(w) { return w["Protocol_ID"] == waveform_selection["protocol"] && w["Meta_Protocol_ID"] == waveform_selection["meta_protocol"] })
                  .select(function(w) { return { "ID": w["Waveform_Label"], "Name": w["Waveform_Label"]} })
                  .distinct(function(p) { return p["ID"]+p["Name"] })

              labels_lookup = labels.toArray();
              var label_count = labels_lookup.length;

              if (label_count > 1) { // If there is more than one label

                  var labels_slider_div = jQuery("#labels .slider");

                  //Set the upper selection limit on the slider
                  labels_slider_div.slider('option','max', label_count-1);

                  //Trigger change event on slider, to update the plots. Keeping the same value
                  labels_slider_div.slider('value', labels_slider_div.slider('value'))

                  jQuery("#labels").show();
              }
              else { // If no labels
                  onLabelSelected(0);

                  jQuery("#labels").hide();
              }
          }
          function onLabelSelected(slider_value) {
              label = labels_lookup[slider_value]

              jQuery( "#labels .value" ).html( label["Name"] );

              waveform_selection["label"] = label["ID"];

              updatePlots()
          }

          function updatePlots() {
              var url = "http://spike.asu.edu:5000/api/plot_waveforms?" +
                    "model_id=" + encodeURIComponent(model_id) +
                    "&protocol_id=" + encodeURIComponent(waveform_selection["protocol"]) +
                    "&meta_protocol_id=" + encodeURIComponent(waveform_selection["meta_protocol"])

              if (!(url in waveform_cached_urls)) {
                  waveform_cached_urls[url] = true;

                  jQuery.ajax(url, {
                      success: function (data) {
                          var waveforms_full = eval(data);

                          // Transform to chart.js format and cache
                          for (w = 0; w < waveforms_full.length; w++) {
                              var wave = waveforms_full[w];
                              var transformed = to_chartjs_format(wave);
                              waveform_cache.push(transformed);
                          }

                          plotSelected();

                      },
                      error: function (jqXHR, status, error) {
                        alert(error);
                      }
                  });
              }
              else {
                  plotSelected();
              }
          }

          function plotSelected() {
              protocol = waveform_selection["protocol"];
              meta_protocol = waveform_selection["meta_protocol"];
              label = waveform_selection["label"];

              label_waveforms = Enumerable
                      .from(waveform_cache)
                      .where(w=>w["Meta_Protocol_ID"] == meta_protocol && w["Protocol_ID"] == protocol)

              //if (model_type != "Channel") {
                  label_waveforms = label_waveforms
                          .where(w=>w["Waveform_Label"] == label)
              //}

              Enumerable.from(variables).forEach(variable => {
                  var v = variable["Name"];
                  var canvasID = "canvas"+v;

                  var chart_waveforms = label_waveforms
                      .where(w => w["Variable_Name"] == v);

                  var variable_waveforms = Enumerable
                          .from(waveform_cache)
                          .where(w => w["Protocol_ID"] == protocol && w["Variable_Name"] == v);

                  var max_y = variable_waveforms.max(w => w["max_y"]);
                  var min_y = variable_waveforms.min(w => w["min_y"]);
                  var range = max_y - min_y;
                  max_y += 0.05 * range;
                  min_y -= 0.05 * range;

                  updateChart(canvasID, { "datasets": chart_waveforms.toArray()}, min_y, max_y);
              });

          }

      </script>
      <div id="plot-selectors">

        <div id="protocols" class="selector">
          <div class="caption">Protocol:</div>
          <select></select>
        </div>

        <div id="meta-protocols" class="selector">
          <div class="caption"><span><%= @meta_protocol_type %>:</span> <span class="value">-</span></div>
          <div class="slider"></div>
        </div>

        <div id="labels" class="selector">
          <div class="caption"><span>Stimulus:</span> <span class="value">-</span></div>
          <div class="slider"></div>
        </div>

        <div style="clear:both;"></div>
      </div>

      <!--Render plots using chart.js library-->
      <div id="canvases">
      </div>

      <script>
          plotsInit();
      </script>

  <% else %>
      <%= @clamp_type %> clamp data not available for this <%= @type.downcase %>.
  <% end %>
</div>